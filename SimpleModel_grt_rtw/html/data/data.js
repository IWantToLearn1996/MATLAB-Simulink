var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"SimpleModel","ref":false,"files":[{"name":"SimpleModel.cpp","type":"source","group":"model","path":"C:\\Git Repository\\MATLAB-Simulink\\SimpleModel_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * SimpleModel.cpp\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleModel\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\r\n * C++ source code generated on : Sun Feb 26 14:39:22 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: 32-bit Generic\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"SimpleModel.h\"\r\n#include \"SimpleModel_private.h\"\r\n\r\n/* Model step function */\r\nvoid SimpleModel::step()\r\n{\r\n  /* Update absolute time for base rate */\r\n  /* The \"clockTick0\" counts the number of times the code of this task has\r\n   * been executed. The absolute time is the multiplication of \"clockTick0\"\r\n   * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\r\n   * overflow during the application lifespan selected.\r\n   */\r\n  (&SimpleModel_M)->Timing.t[0] =\r\n    ((time_T)(++(&SimpleModel_M)->Timing.clockTick0)) * (&SimpleModel_M)\r\n    ->Timing.stepSize0;\r\n\r\n  {\r\n    /* Update absolute timer for sample time: [0.2s, 0.0s] */\r\n    /* The \"clockTick1\" counts the number of times the code of this task has\r\n     * been executed. The resolution of this integer timer is 0.2, which is the step size\r\n     * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\r\n     * application lifespan selected.\r\n     */\r\n    (&SimpleModel_M)->Timing.clockTick1++;\r\n  }\r\n}\r\n\r\n/* Model initialize function */\r\nvoid SimpleModel::initialize()\r\n{\r\n  /* Registration code */\r\n  {\r\n    /* Setup solver object */\r\n    rtsiSetSimTimeStepPtr(&(&SimpleModel_M)->solverInfo, &(&SimpleModel_M)\r\n                          ->Timing.simTimeStep);\r\n    rtsiSetTPtr(&(&SimpleModel_M)->solverInfo, &rtmGetTPtr((&SimpleModel_M)));\r\n    rtsiSetStepSizePtr(&(&SimpleModel_M)->solverInfo, &(&SimpleModel_M)\r\n                       ->Timing.stepSize0);\r\n    rtsiSetErrorStatusPtr(&(&SimpleModel_M)->solverInfo, (&rtmGetErrorStatus\r\n      ((&SimpleModel_M))));\r\n    rtsiSetRTModelPtr(&(&SimpleModel_M)->solverInfo, (&SimpleModel_M));\r\n  }\r\n\r\n  rtsiSetSimTimeStep(&(&SimpleModel_M)->solverInfo, MAJOR_TIME_STEP);\r\n  rtsiSetSolverName(&(&SimpleModel_M)->solverInfo,\"FixedStepDiscrete\");\r\n  rtmSetTPtr((&SimpleModel_M), &(&SimpleModel_M)->Timing.tArray[0]);\r\n  (&SimpleModel_M)->Timing.stepSize0 = 0.2;\r\n}\r\n\r\n/* Model terminate function */\r\nvoid SimpleModel::terminate()\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n\r\n/* Constructor */\r\nSimpleModel::SimpleModel() :\r\n  SimpleModel_DW(),\r\n  SimpleModel_M()\r\n{\r\n  /* Currently there is no constructor body generated.*/\r\n}\r\n\r\n/* Destructor */\r\nSimpleModel::~SimpleModel()\r\n{\r\n  /* Currently there is no destructor body generated.*/\r\n}\r\n\r\n/* Real-Time Model get method */\r\nRT_MODEL_SimpleModel_T * SimpleModel::getRTM()\r\n{\r\n  return (&SimpleModel_M);\r\n}\r\n"},{"name":"SimpleModel.h","type":"header","group":"model","path":"C:\\Git Repository\\MATLAB-Simulink\\SimpleModel_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * SimpleModel.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleModel\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\r\n * C++ source code generated on : Sun Feb 26 14:39:22 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: 32-bit Generic\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_SimpleModel_h_\r\n#define RTW_HEADER_SimpleModel_h_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#include \"SimpleModel_types.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmGetT\r\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\r\n#endif\r\n\r\n#ifndef rtmGetTPtr\r\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\r\n#endif\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\nstruct DW_SimpleModel_T {\r\n  real_T LTI_STATE_1_FirstOutput;      /* '<S6>/LTI_STATE_1' */\r\n  boolean_T LTI_STATE_1_ReInit;        /* '<S6>/LTI_STATE_1' */\r\n};\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_SimpleModel_T {\r\n  const char_T *errorStatus;\r\n  RTWSolverInfo solverInfo;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    uint32_T clockTick0;\r\n    time_T stepSize0;\r\n    uint32_T clockTick1;\r\n    SimTimeStep simTimeStep;\r\n    time_T *t;\r\n    time_T tArray[2];\r\n  } Timing;\r\n};\r\n\r\n/* Class declaration for model SimpleModel */\r\nclass SimpleModel final\r\n{\r\n  /* public data and function members */\r\n public:\r\n  /* Copy Constructor */\r\n  SimpleModel(SimpleModel const&) = delete;\r\n\r\n  /* Assignment Operator */\r\n  SimpleModel& operator= (SimpleModel const&) & = delete;\r\n\r\n  /* Move Constructor */\r\n  SimpleModel(SimpleModel &&) = delete;\r\n\r\n  /* Move Assignment Operator */\r\n  SimpleModel& operator= (SimpleModel &&) = delete;\r\n\r\n  /* Real-Time Model get method */\r\n  RT_MODEL_SimpleModel_T * getRTM();\r\n\r\n  /* Initial conditions function */\r\n  void initialize();\r\n\r\n  /* model step function */\r\n  void step();\r\n\r\n  /* model terminate function */\r\n  static void terminate();\r\n\r\n  /* Constructor */\r\n  SimpleModel();\r\n\r\n  /* Destructor */\r\n  ~SimpleModel();\r\n\r\n  /* private data and function members */\r\n private:\r\n  /* Block states */\r\n  DW_SimpleModel_T SimpleModel_DW;\r\n\r\n  /* Real-Time Model */\r\n  RT_MODEL_SimpleModel_T SimpleModel_M;\r\n};\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<Root>/Scope' : Unused code path elimination\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'SimpleModel'\r\n * '<S1>'   : 'SimpleModel/PS-Simulink Converter'\r\n * '<S2>'   : 'SimpleModel/PS-Simulink Converter1'\r\n * '<S3>'   : 'SimpleModel/Solver Configuration'\r\n * '<S4>'   : 'SimpleModel/PS-Simulink Converter/EVAL_KEY'\r\n * '<S5>'   : 'SimpleModel/PS-Simulink Converter1/EVAL_KEY'\r\n * '<S6>'   : 'SimpleModel/Solver Configuration/EVAL_KEY'\r\n */\r\n#endif                                 /* RTW_HEADER_SimpleModel_h_ */\r\n"},{"name":"SimpleModel_private.h","type":"header","group":"model","path":"C:\\Git Repository\\MATLAB-Simulink\\SimpleModel_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * SimpleModel_private.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleModel\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\r\n * C++ source code generated on : Sun Feb 26 14:39:22 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: 32-bit Generic\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_SimpleModel_private_h_\r\n#define RTW_HEADER_SimpleModel_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n\r\n/* Private macros used by the generated code to access rtModel */\r\n#ifndef rtmIsMajorTimeStep\r\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmIsMinorTimeStep\r\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmSetTPtr\r\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\r\n#endif\r\n#endif                                 /* RTW_HEADER_SimpleModel_private_h_ */\r\n"},{"name":"SimpleModel_types.h","type":"header","group":"model","path":"C:\\Git Repository\\MATLAB-Simulink\\SimpleModel_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * SimpleModel_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleModel\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\r\n * C++ source code generated on : Sun Feb 26 14:39:22 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: 32-bit Generic\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_SimpleModel_types_h_\r\n#define RTW_HEADER_SimpleModel_types_h_\r\n\r\n/* Model Code Variants */\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_SimpleModel_T RT_MODEL_SimpleModel_T;\r\n\r\n#endif                                 /* RTW_HEADER_SimpleModel_types_h_ */\r\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"C:\\Git Repository\\MATLAB-Simulink\\SimpleModel_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * multiword_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleModel\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\r\n * C++ source code generated on : Sun Feb 26 14:39:22 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: 32-bit Generic\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * MultiWord supporting definitions\r\n */\r\ntypedef long long longlong_T;\r\n\r\n/*\r\n * MultiWord types\r\n */\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} int128m_T;\r\n\r\ntypedef struct {\r\n  int128m_T re;\r\n  int128m_T im;\r\n} cint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} uint128m_T;\r\n\r\ntypedef struct {\r\n  uint128m_T re;\r\n  uint128m_T im;\r\n} cuint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} int192m_T;\r\n\r\ntypedef struct {\r\n  int192m_T re;\r\n  int192m_T im;\r\n} cint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} uint192m_T;\r\n\r\ntypedef struct {\r\n  uint192m_T re;\r\n  uint192m_T im;\r\n} cuint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} int256m_T;\r\n\r\ntypedef struct {\r\n  int256m_T re;\r\n  int256m_T im;\r\n} cint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} uint256m_T;\r\n\r\ntypedef struct {\r\n  uint256m_T re;\r\n  uint256m_T im;\r\n} cuint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} int320m_T;\r\n\r\ntypedef struct {\r\n  int320m_T re;\r\n  int320m_T im;\r\n} cint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} uint320m_T;\r\n\r\ntypedef struct {\r\n  uint320m_T re;\r\n  uint320m_T im;\r\n} cuint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} int384m_T;\r\n\r\ntypedef struct {\r\n  int384m_T re;\r\n  int384m_T im;\r\n} cint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} uint384m_T;\r\n\r\ntypedef struct {\r\n  uint384m_T re;\r\n  uint384m_T im;\r\n} cuint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} int448m_T;\r\n\r\ntypedef struct {\r\n  int448m_T re;\r\n  int448m_T im;\r\n} cint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} uint448m_T;\r\n\r\ntypedef struct {\r\n  uint448m_T re;\r\n  uint448m_T im;\r\n} cuint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} int512m_T;\r\n\r\ntypedef struct {\r\n  int512m_T re;\r\n  int512m_T im;\r\n} cint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} uint512m_T;\r\n\r\ntypedef struct {\r\n  uint512m_T re;\r\n  uint512m_T im;\r\n} cuint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} int576m_T;\r\n\r\ntypedef struct {\r\n  int576m_T re;\r\n  int576m_T im;\r\n} cint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} uint576m_T;\r\n\r\ntypedef struct {\r\n  uint576m_T re;\r\n  uint576m_T im;\r\n} cuint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} int640m_T;\r\n\r\ntypedef struct {\r\n  int640m_T re;\r\n  int640m_T im;\r\n} cint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} uint640m_T;\r\n\r\ntypedef struct {\r\n  uint640m_T re;\r\n  uint640m_T im;\r\n} cuint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} int704m_T;\r\n\r\ntypedef struct {\r\n  int704m_T re;\r\n  int704m_T im;\r\n} cint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} uint704m_T;\r\n\r\ntypedef struct {\r\n  uint704m_T re;\r\n  uint704m_T im;\r\n} cuint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} int768m_T;\r\n\r\ntypedef struct {\r\n  int768m_T re;\r\n  int768m_T im;\r\n} cint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} uint768m_T;\r\n\r\ntypedef struct {\r\n  uint768m_T re;\r\n  uint768m_T im;\r\n} cuint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} int832m_T;\r\n\r\ntypedef struct {\r\n  int832m_T re;\r\n  int832m_T im;\r\n} cint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} uint832m_T;\r\n\r\ntypedef struct {\r\n  uint832m_T re;\r\n  uint832m_T im;\r\n} cuint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} int896m_T;\r\n\r\ntypedef struct {\r\n  int896m_T re;\r\n  int896m_T im;\r\n} cint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} uint896m_T;\r\n\r\ntypedef struct {\r\n  uint896m_T re;\r\n  uint896m_T im;\r\n} cuint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} int960m_T;\r\n\r\ntypedef struct {\r\n  int960m_T re;\r\n  int960m_T im;\r\n} cint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} uint960m_T;\r\n\r\ntypedef struct {\r\n  uint960m_T re;\r\n  uint960m_T im;\r\n} cuint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} int1024m_T;\r\n\r\ntypedef struct {\r\n  int1024m_T re;\r\n  int1024m_T im;\r\n} cint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} uint1024m_T;\r\n\r\ntypedef struct {\r\n  uint1024m_T re;\r\n  uint1024m_T im;\r\n} cuint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} int1088m_T;\r\n\r\ntypedef struct {\r\n  int1088m_T re;\r\n  int1088m_T im;\r\n} cint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} uint1088m_T;\r\n\r\ntypedef struct {\r\n  uint1088m_T re;\r\n  uint1088m_T im;\r\n} cuint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} int1152m_T;\r\n\r\ntypedef struct {\r\n  int1152m_T re;\r\n  int1152m_T im;\r\n} cint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} uint1152m_T;\r\n\r\ntypedef struct {\r\n  uint1152m_T re;\r\n  uint1152m_T im;\r\n} cuint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} int1216m_T;\r\n\r\ntypedef struct {\r\n  int1216m_T re;\r\n  int1216m_T im;\r\n} cint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} uint1216m_T;\r\n\r\ntypedef struct {\r\n  uint1216m_T re;\r\n  uint1216m_T im;\r\n} cuint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} int1280m_T;\r\n\r\ntypedef struct {\r\n  int1280m_T re;\r\n  int1280m_T im;\r\n} cint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} uint1280m_T;\r\n\r\ntypedef struct {\r\n  uint1280m_T re;\r\n  uint1280m_T im;\r\n} cuint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} int1344m_T;\r\n\r\ntypedef struct {\r\n  int1344m_T re;\r\n  int1344m_T im;\r\n} cint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} uint1344m_T;\r\n\r\ntypedef struct {\r\n  uint1344m_T re;\r\n  uint1344m_T im;\r\n} cuint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} int1408m_T;\r\n\r\ntypedef struct {\r\n  int1408m_T re;\r\n  int1408m_T im;\r\n} cint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} uint1408m_T;\r\n\r\ntypedef struct {\r\n  uint1408m_T re;\r\n  uint1408m_T im;\r\n} cuint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} int1472m_T;\r\n\r\ntypedef struct {\r\n  int1472m_T re;\r\n  int1472m_T im;\r\n} cint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} uint1472m_T;\r\n\r\ntypedef struct {\r\n  uint1472m_T re;\r\n  uint1472m_T im;\r\n} cuint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} int1536m_T;\r\n\r\ntypedef struct {\r\n  int1536m_T re;\r\n  int1536m_T im;\r\n} cint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} uint1536m_T;\r\n\r\ntypedef struct {\r\n  uint1536m_T re;\r\n  uint1536m_T im;\r\n} cuint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} int1600m_T;\r\n\r\ntypedef struct {\r\n  int1600m_T re;\r\n  int1600m_T im;\r\n} cint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} uint1600m_T;\r\n\r\ntypedef struct {\r\n  uint1600m_T re;\r\n  uint1600m_T im;\r\n} cuint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} int1664m_T;\r\n\r\ntypedef struct {\r\n  int1664m_T re;\r\n  int1664m_T im;\r\n} cint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} uint1664m_T;\r\n\r\ntypedef struct {\r\n  uint1664m_T re;\r\n  uint1664m_T im;\r\n} cuint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} int1728m_T;\r\n\r\ntypedef struct {\r\n  int1728m_T re;\r\n  int1728m_T im;\r\n} cint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} uint1728m_T;\r\n\r\ntypedef struct {\r\n  uint1728m_T re;\r\n  uint1728m_T im;\r\n} cuint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} int1792m_T;\r\n\r\ntypedef struct {\r\n  int1792m_T re;\r\n  int1792m_T im;\r\n} cint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} uint1792m_T;\r\n\r\ntypedef struct {\r\n  uint1792m_T re;\r\n  uint1792m_T im;\r\n} cuint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} int1856m_T;\r\n\r\ntypedef struct {\r\n  int1856m_T re;\r\n  int1856m_T im;\r\n} cint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} uint1856m_T;\r\n\r\ntypedef struct {\r\n  uint1856m_T re;\r\n  uint1856m_T im;\r\n} cuint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} int1920m_T;\r\n\r\ntypedef struct {\r\n  int1920m_T re;\r\n  int1920m_T im;\r\n} cint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} uint1920m_T;\r\n\r\ntypedef struct {\r\n  uint1920m_T re;\r\n  uint1920m_T im;\r\n} cuint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} int1984m_T;\r\n\r\ntypedef struct {\r\n  int1984m_T re;\r\n  int1984m_T im;\r\n} cint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} uint1984m_T;\r\n\r\ntypedef struct {\r\n  uint1984m_T re;\r\n  uint1984m_T im;\r\n} cuint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} int2048m_T;\r\n\r\ntypedef struct {\r\n  int2048m_T re;\r\n  int2048m_T im;\r\n} cint2048m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} uint2048m_T;\r\n\r\ntypedef struct {\r\n  uint2048m_T re;\r\n  uint2048m_T im;\r\n} cuint2048m_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Git Repository\\MATLAB-Simulink\\SimpleModel_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleModel\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\r\n * C++ source code generated on : Sun Feb 26 14:39:22 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: 32-bit Generic\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n#include \"tmwtypes.h\"\r\n#ifndef POINTER_T\r\n#define POINTER_T\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n#ifndef INT64_T\r\n#define INT64_T\r\n\r\ntypedef long long int64_T;\r\n\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#endif\r\n\r\n#ifndef UINT64_T\r\n#define UINT64_T\r\n\r\ntypedef unsigned long long uint64_T;\r\n\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n#endif\r\n\r\n/*===========================================================================*\r\n * Additional complex number type definitions                                           *\r\n *===========================================================================*/\r\n#ifndef CINT64_T\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#endif\r\n\r\n#ifndef CUINT64_T\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n#endif\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Git Repository\\MATLAB-Simulink\\SimpleModel_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n *  rtmodel.h:\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"SimpleModel\".\r\n *\r\n * Model version              : 7.0\r\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\r\n * C++ source code generated on : Sun Feb 26 14:39:22 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: 32-bit Generic\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (MATLAB Host)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"SimpleModel.h\"\r\n#define MODEL_CLASSNAME                SimpleModel\r\n#define MODEL_STEPNAME                 step\r\n#define GRTINTERFACE                   0\r\n\r\n/*\r\n * ROOT_IO_FORMAT: 0 (Individual arguments)\r\n * ROOT_IO_FORMAT: 1 (Structure reference)\r\n * ROOT_IO_FORMAT: 2 (Part of model data structure)\r\n */\r\n#define ROOT_IO_FORMAT                 2\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n"},{"name":"pm_printf.c","type":"source","group":"legacy","path":"C:\\Git Repository\\MATLAB-Simulink\\SimpleModel_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Simscape target specific file.\n * Abstract:\n *\n *    Conditionally include implementations for wrappers of printf\n *    functionality.\n *\n * Copyright 2015-2016 The MathWorks, Inc.\n */\n\n/* only Visual compile printf implementations */\n\n#if defined(_MSC_VER)\n#include \"pm_printf.h\"\n\n#else\n/*\n * included to avoid empty translation unit\n */\ntypedef int pm_printf_dummy;\n#endif\n"},{"name":"rt_backsubrr_dbl.c","type":"source","group":"legacy","path":"C:\\Git Repository\\MATLAB-Simulink\\SimpleModel_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\r\n *\r\n * File: rt_backsubrr_dbl.c     \r\n *\r\n * Abstract:\r\n *      Simulink Coder support routine which performs\r\n *      backward substitution: solving Ux=b for real\r\n *      double precision float operands.\r\n *\r\n */\r\n\r\n#include \"rt_matrixlib.h\"\r\n\r\n/* Function: rt_BackwardSubstitutionRR_Dbl =====================================\r\n * Abstract: Backward substitution: Solving Ux=b \r\n *           U: real, double\r\n *           b: real, double\r\n *           U is an upper (or unit upper) triangular full matrix.\r\n *           The entries in the lower triangle are ignored.\r\n *           U is a NxN matrix\r\n *           X is a NxP matrix\r\n *           B is a NxP matrix\r\n */\r\nvoid rt_BackwardSubstitutionRR_Dbl(real_T          *pU,\r\n                                   const real_T    *pb,\r\n                                   real_T          *x,\r\n                                   int_T            N,\r\n                                   int_T            P,\r\n                                   boolean_T        unit_upper)\r\n{\r\n  int_T i,k;\r\n  for(k=P; k>0; k--) {\r\n    real_T *pUcol = pU;\r\n    for(i=0; i<N; i++) {\r\n      real_T *xj = x + k*N-1;\r\n      real_T s = 0.0;\r\n      real_T *pUrow = pUcol--;          /* access current row of U */\r\n\r\n      {\r\n        int_T j = i;\r\n        while(j-- > 0) {\r\n          s += *pUrow * *xj--;\r\n          pUrow -= N;\r\n        }\r\n      }\r\n\r\n      if (unit_upper) {\r\n        *xj = *pb-- - s;\r\n      } else {\r\n        *xj = (*pb-- - s) / *pUrow;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/* [EOF] rt_backsubrr_dbl.c */\r\n"},{"name":"rt_forwardsubrr_dbl.c","type":"source","group":"legacy","path":"C:\\Git Repository\\MATLAB-Simulink\\SimpleModel_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\r\n *\r\n * File: rt_forwardsubrr_dbl.c     \r\n *\r\n * Abstract:\r\n *      Simulink Coder support routine which performs\r\n *      forward substitution: solving Lx=b\r\n *\r\n */\r\n\r\n#include \"rt_matrixlib.h\"\r\n\r\n/* Function: rt_ForwardSubstitutionRR_Dbl ======================================\r\n * Abstract: Forward substitution: solving Lx=b \r\n *           L: Real, double\r\n *           b: Real, double\r\n *           L is a lower (or unit lower) triangular full matrix.\r\n *           The entries in the upper triangle are ignored.\r\n *           L is a NxN matrix\r\n *           X is a NxP matrix\r\n *           B is a NxP matrix\r\n */\r\nvoid rt_ForwardSubstitutionRR_Dbl(real_T        *pL,\r\n                                  const real_T  *pb,\r\n                                  real_T        *x,\r\n                                  int_T          N,\r\n                                  int_T          P,\r\n                                  const int32_T *piv,\r\n                                  boolean_T      unit_lower)\r\n{  \r\n  /* Real inputs: */\r\n  int_T i, k;\r\n  for(k=0; k<P; k++) {\r\n    real_T *pLcol = pL;\r\n    for(i=0; i<N; i++) {\r\n      real_T *xj = x + k*N;\r\n      real_T s = 0.0;\r\n      real_T *pLrow = pLcol++;          /* access current row of L */\r\n\r\n      {\r\n        int_T j = i;\r\n        while(j-- > 0) {\r\n          s += *pLrow * *xj;\r\n          pLrow += N;\r\n          xj++;\r\n        }\r\n      }\r\n\r\n      if (unit_lower) {\r\n        *xj = pb[piv[i]] - s;\r\n      } else {\r\n        *xj = (pb[piv[i]] - s) / *pLrow;\r\n      }\r\n    }\r\n    pb += N;\r\n  }\r\n}\r\n\r\n/* [EOF] rt_forwardsubrr_dbl.c */\r\n"},{"name":"rt_lu_real.c","type":"source","group":"legacy","path":"C:\\Git Repository\\MATLAB-Simulink\\SimpleModel_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2010 The MathWorks, Inc.\r\n *\r\n * File: rt_lu_real.c     \r\n *\r\n * Abstract:\r\n *      Real-Time Workshop support routine for lu_real\r\n *\r\n */\r\n\r\n#include <math.h>\r\n#include \"rt_matrixlib.h\"\r\n\r\n/* Function: rt_lu_real  =======================================================\r\n * Abstract: A is real.\r\n *\r\n */\r\nvoid rt_lu_real(real_T      *A,    /* in and out                         */\r\n                const int_T n,     /* number or rows = number of columns */\r\n                int32_T     *piv)  /* pivote vector                      */\r\n{\r\n  int_T k;\r\n\r\n  /* initialize row-pivot indices: */\r\n  for (k = 0; k < n; k++) {\r\n    piv[k] = k;\r\n  }\r\n\r\n  /* Loop over each column: */\r\n  for (k = 0; k < n; k++) {\r\n    const int_T kn = k*n;\r\n    int_T p = k;\r\n\r\n    /* Scan the lower triangular part of this column only\r\n     * Record row of largest value\r\n     */\r\n    {\r\n      int_T i;\r\n      real_T Amax = fabs(A[p+kn]);      /* assume diag is max */\r\n      for (i = k+1; i < n; i++) {\r\n        real_T q = fabs(A[i+kn]);\r\n        if (q > Amax) {p = i; Amax = q;}\r\n      }\r\n    }\r\n\r\n    /* swap rows if required */\r\n    if (p != k) {\r\n      int_T j;\r\n      int32_T t1;\r\n      for (j = 0; j < n; j++) {\r\n        real_T t;\r\n        const int_T j_n = j*n;\r\n        t = A[p+j_n]; A[p+j_n] = A[k+j_n]; A[k+j_n] = t;\r\n      }\r\n      /* swap pivot row indices */\r\n      t1 = piv[p]; piv[p] = piv[k]; piv[k] = t1;\r\n    }\r\n\r\n    /* column reduction */\r\n    {\r\n      real_T Adiag = A[k+kn];\r\n      int_T i,j;\r\n      if (Adiag != 0.0) {               /* non-zero diagonal entry */\r\n\r\n        /* divide lower triangular part of column by max */\r\n        Adiag = 1.0/Adiag;\r\n        for (i = k+1; i < n; i++) {\r\n          A[i+kn] *= Adiag;\r\n        }\r\n\r\n        /* subtract multiple of column from remaining columns */\r\n        for (j = k+1; j < n; j++) {\r\n          int_T j_n = j*n;\r\n          for (i = k+1; i < n; i++) {\r\n            A[i+j_n] -= A[i+kn]*A[k+j_n];\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/* [EOF] rt_lu_real.c */\r\n"},{"name":"rt_matrixlib.h","type":"header","group":"other","path":"C:\\Git Repository\\MATLAB-Simulink\\SimpleModel_grt_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef rt_matrixlib_h\r\n#define rt_matrixlib_h\r\n\r\n/* Copyright 2007-2013 The MathWorks, Inc.\r\n *\r\n * File    : rt_matrixlib.h\r\n * Abstract:\r\n *     Function prototypes for .c sources in rtw/c/src/matrixmath.\r\n *\r\n */\r\n\r\n\r\n/*==========*\r\n * Includes *\r\n *==========*/\r\n\r\n#include \"rtwtypes.h\"\r\n#include <limits.h>\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n/* Matrix Multiplication Utility Functions */\r\nextern void rt_MatMultRR_Dbl(real_T         *y, \r\n                             const real_T   *A, \r\n                             const real_T   *B, \r\n                             const int_T dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultRC_Dbl(creal_T       *y,\r\n                             const real_T  *A,\r\n                             const creal_T *B,\r\n                             const int_T dims[3]);\r\n\r\nextern void rt_MatMultCR_Dbl(creal_T       *y,\r\n                             const creal_T *A,\r\n                             const real_T  *B,\r\n                             const int_T dims[3]);\r\n\r\nextern void rt_MatMultCC_Dbl(creal_T       *y,\r\n                             const creal_T *A,\r\n                             const creal_T *B,\r\n                             const int_T dims[3]);\r\n#endif\r\n\r\nextern void rt_MatMultRR_Sgl(real32_T       *y,\r\n                             const real32_T *A,\r\n                             const real32_T *B,\r\n                             const int_T  dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultRC_Sgl(creal32_T       *y,\r\n                             const real32_T  *A,\r\n                             const creal32_T *B,\r\n                             const int_T   dims[3]);\r\n\r\nextern void rt_MatMultCR_Sgl(creal32_T       *y,\r\n                             const creal32_T *A,\r\n                             const real32_T  *B,\r\n                             const int_T   dims[3]);\r\n\r\nextern void rt_MatMultCC_Sgl(creal32_T       *y,\r\n                             const creal32_T *A,\r\n                             const creal32_T *B,\r\n                             const int_T   dims[3]);\r\n#endif\r\n\r\nextern void rt_MatMultAndIncRR_Dbl(real_T       *y,\r\n                                   const real_T *A,\r\n                                   const real_T *B,\r\n                                   const int_T dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultAndIncRC_Dbl(creal_T       *y,\r\n                                   const real_T  *A,\r\n                                   const creal_T *B,\r\n                                   const int_T dims[3]);\r\n\r\nextern void rt_MatMultAndIncCR_Dbl(creal_T       *y,\r\n                                   const creal_T *A,\r\n                                   const real_T  *B,\r\n                                   const int_T dims[3]);\r\n\r\nextern void rt_MatMultAndIncCC_Dbl(creal_T       *y,\r\n                                   const creal_T *A,\r\n                                   const creal_T *B,\r\n                                   const int_T dims[3]);\r\n#endif\r\nextern void rt_MatMultAndIncRR_Sgl(real32_T       *y,\r\n                                   const real32_T *A,\r\n                                   const real32_T *B,\r\n                                   const int_T  dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatMultAndIncRC_Sgl(creal32_T       *y,\r\n                                   const real32_T  *A,\r\n                                   const creal32_T *B,\r\n                                   const int_T   dims[3]);\r\n\r\nextern void rt_MatMultAndIncCR_Sgl(creal32_T       *y,\r\n                                   const creal32_T *A,\r\n                                   const real32_T  *B,\r\n                                   const int_T   dims[3]);\r\n\r\nextern void rt_MatMultAndIncCC_Sgl(creal32_T       *y,\r\n                                   const creal32_T *A,\r\n                                   const creal32_T *B,\r\n                                   const int_T   dims[3]);\r\n#endif \r\n\r\n/* Matrix Inversion Utility Functions */\r\nextern void rt_lu_real(real_T      *A,\r\n                       const int_T n,\r\n                       int32_T     *piv);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_lu_cplx(creal_T *A,\r\n                       const int_T n,\r\n                       int32_T *piv);\r\n#endif\r\n\r\nextern void rt_lu_real_sgl(real32_T      *A,\r\n                           const int_T n,\r\n                           int32_T     *piv);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_lu_cplx_sgl(creal32_T *A,\r\n                           const int_T n,\r\n                           int32_T *piv);\r\n#endif\r\n\r\nextern void rt_BackwardSubstitutionRR_Dbl(real_T          *pU,\r\n                                          const real_T    *pb,\r\n                                          real_T          *x,\r\n                                          int_T            N,\r\n                                          int_T            P,\r\n                                          boolean_T        unit_upper);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_BackwardSubstitutionRC_Dbl(real_T          *pU,\r\n                                          const creal_T   *pb,\r\n                                          creal_T         *x,\r\n                                          int_T            N,\r\n                                          int_T            P,\r\n                                          boolean_T        unit_upper);\r\n\r\nextern void rt_BackwardSubstitutionCC_Dbl(creal_T         *pU,\r\n                                          const creal_T   *pb,\r\n                                          creal_T         *x,\r\n                                          int_T            N,\r\n                                          int_T            P,\r\n                                          boolean_T        unit_upper);\r\n#endif\r\n\r\nextern void rt_ForwardSubstitutionRR_Dbl(real_T        *pL,\r\n                                         const real_T  *pb,\r\n                                         real_T        *x,\r\n                                         int_T          N,\r\n                                         int_T          P,\r\n                                         const int32_T *piv,\r\n                                         boolean_T      unit_lower);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_ForwardSubstitutionRC_Dbl(real_T        *pL,\r\n                                         const creal_T   *pb,\r\n                                         creal_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCR_Dbl(creal_T   *pL,\r\n                                         const real_T    *pb,\r\n                                         creal_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCC_Dbl(creal_T   *pL,\r\n                                         const creal_T   *pb,\r\n                                         creal_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n#endif\r\n\r\nextern void rt_BackwardSubstitutionRR_Sgl(real32_T          *pU,\r\n                                          const real32_T    *pb,\r\n                                          real32_T          *x,\r\n                                          int_T              N,\r\n                                          int_T              P,\r\n                                          boolean_T          unit_upper);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_BackwardSubstitutionRC_Sgl(real32_T          *pU,\r\n                                          const creal32_T   *pb,\r\n                                          creal32_T         *x,\r\n                                          int_T              N,\r\n                                          int_T              P,\r\n                                          boolean_T          unit_upper);\r\n\r\nextern void rt_BackwardSubstitutionCC_Sgl(creal32_T         *pU,\r\n                                          const creal32_T   *pb,\r\n                                          creal32_T         *x,\r\n                                          int_T              N,\r\n                                          int_T              P,\r\n                                          boolean_T          unit_upper);\r\n#endif\r\n\r\nextern void rt_ForwardSubstitutionRR_Sgl(real32_T    *pL,\r\n                                         const real32_T    *pb,\r\n                                         real32_T    *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_ForwardSubstitutionRC_Sgl(real32_T    *pL,\r\n                                         const creal32_T   *pb,\r\n                                         creal32_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCR_Sgl(creal32_T   *pL,\r\n                                         const real32_T    *pb,\r\n                                         creal32_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n\r\nextern void rt_ForwardSubstitutionCC_Sgl(creal32_T   *pL,\r\n                                         const creal32_T   *pb,\r\n                                         creal32_T   *x,\r\n                                         int_T     N,\r\n                                         int_T     P,\r\n                                         const int32_T   *piv,\r\n                                         boolean_T unit_lower);\r\n#endif\r\n\r\n\r\nextern void rt_MatDivRR_Dbl(real_T        *Out,\r\n                            const real_T  *In1,\r\n                            const real_T  *In2,\r\n                            real_T        *lu,\r\n                            int32_T       *piv,\r\n                            real_T        *x,\r\n                            const int_T    dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatDivRC_Dbl(creal_T       *Out,\r\n                            const real_T  *In1,\r\n                            const creal_T *In2,\r\n                            real_T        *lu,\r\n                            int32_T       *piv,\r\n                            creal_T       *x,\r\n                            const int_T    dims[3]);\r\n\r\nextern void rt_MatDivCR_Dbl(creal_T       *Out,\r\n                            const creal_T *In1,\r\n                            const real_T  *In2,\r\n                            creal_T       *lu,\r\n                            int32_T       *piv,\r\n                            creal_T       *x,\r\n                            const int_T    dims[3]);\r\n\r\nextern void rt_MatDivCC_Dbl(creal_T       *Out,\r\n                            const creal_T *In1,\r\n                            const creal_T *In2,\r\n                            creal_T       *lu,\r\n                            int32_T       *piv,\r\n                            creal_T       *x,\r\n                            const int_T    dims[3]);\r\n#endif\r\n\r\nextern void rt_MatDivRR_Sgl(real32_T        *Out,\r\n                            const real32_T  *In1,\r\n                            const real32_T  *In2,\r\n                            real32_T        *lu,\r\n                            int32_T         *piv,\r\n                            real32_T        *x,\r\n                            const int_T      dims[3]);\r\n\r\n#ifdef CREAL_T\r\nextern void rt_MatDivRC_Sgl(creal32_T       *Out,\r\n                            const real32_T  *In1,\r\n                            const creal32_T *In2,\r\n                            real32_T        *lu,\r\n                            int32_T         *piv,\r\n                            creal32_T       *x,\r\n                            const int_T      dims[3]);\r\n\r\nextern void rt_MatDivCR_Sgl(creal32_T       *Out,\r\n                            const creal32_T *In1,\r\n                            const real32_T  *In2,\r\n                            creal32_T       *lu,\r\n                            int32_T         *piv,\r\n                            creal32_T       *x,\r\n                            const int_T      dims[3]);\r\n\r\nextern void rt_MatDivCC_Sgl(creal32_T       *Out,\r\n                            const creal32_T *In1,\r\n                            const creal32_T *In2,\r\n                            creal32_T       *lu,\r\n                            int32_T         *piv,\r\n                            creal32_T       *x,\r\n                            const int_T      dims[3]);\r\n#endif\r\n\r\n\r\n/* Matrix multiplication defines */\r\n\r\n/* Quick (approximate) complex absolute value: */\r\n#define CQABS(X) (fabs((X).re) + fabs((X).im))\r\n\r\n/* Quick (approximate) complex absolute value for singles: */\r\n#define CQABSSGL(X) (real32_T)(fabs( (real_T) (X).re) + fabs( (real_T) (X).im)) \r\n\r\n#ifdef CREAL_T\r\nextern void rt_ComplexTimes_Dbl(creal_T       *Out,\r\n                                const creal_T In1,\r\n                                const creal_T In2);\r\n\r\nextern void rt_ComplexRDivide_Dbl(creal_T       *Out,\r\n                                  const creal_T In1,\r\n                                  const creal_T In2);\r\n\r\nextern void rt_ComplexReciprocal_Dbl(creal_T       *Out,\r\n                                     const creal_T In1);\r\n\r\nextern void rt_ComplexTimes_Sgl(creal32_T       *Out,\r\n                                const creal32_T In1,\r\n                                const creal32_T In2);\r\n\r\nextern void rt_ComplexRDivide_Sgl(creal32_T       *Out,\r\n                                  const creal32_T In1,\r\n                                  const creal32_T In2);\r\n\r\nextern void rt_ComplexReciprocal_Sgl(creal32_T       *Out,\r\n                                     const creal32_T In1);\r\n\r\n#endif\r\n\r\nextern real_T rt_Hypot_Dbl(real_T In1,\r\n                           real_T In2);\r\n\r\nextern real32_T rt_Hypot_Sgl(real32_T In1,\r\n                             real32_T In2);\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif /* rt_matrixlib_h */\r\n"},{"name":"rt_matrixlib_dbl.c","type":"source","group":"legacy","path":"C:\\Git Repository\\MATLAB-Simulink\\SimpleModel_grt_rtw","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2013 The MathWorks, Inc.\r\n *\r\n * File: rt_matrixlib_dbl.c\r\n *\r\n * Abstract:\r\n *      Simulink Coder utility functions\r\n *\r\n */\r\n\r\n#include <math.h>\r\n#include \"rt_matrixlib.h\"\r\n\r\n#ifdef CREAL_T\r\nvoid rt_ComplexTimes_Dbl(creal_T* c,\r\n                         const creal_T a,\r\n                         const creal_T b)\r\n{\r\n    if (a.im == 0.0) {\r\n        c->re = a.re * b.re;\r\n        c->im = a.re * b.im;\r\n        if (b.im == 0.0) {\r\n            c->im = 0.0;\r\n        } else if (b.re == 0.0 || a.re == 0.0) {\r\n            c->re = 0.0;\r\n        }\r\n    } else if (b.im == 0.0) {\r\n        c->re = a.re * b.re;\r\n        c->im = a.im * b.re;\r\n        if (b.re == 0.0 || a.re == 0.0) { \r\n            c->re = 0.0;\r\n        }\r\n    } else if (a.re == 0.0) {\r\n        c->re = -a.im * b.im;\r\n        c->im = a.im * b.re;\r\n        if (b.re == 0.0) {\r\n            c->im = 0.0;\r\n        }\r\n    } else if (b.re == 0.0) {\r\n        c->re = -a.im * b.im;\r\n        c->im = a.re * b.im;\r\n    } else {\r\n        c->re = a.re * b.re - a.im * b.im;\r\n        c->im = a.re * b.im + a.im * b.re;\r\n    }\r\n}\r\n\r\nvoid rt_ComplexRDivide_Dbl(creal_T* c,\r\n                           const creal_T a,\r\n                           const creal_T b)\r\n{\r\n    if (b.im == 0.0) {\r\n        c->re = a.re / b.re;\r\n        if (a.im == 0.0) {\r\n            c->im = 0.0;\r\n        } else { /* a.im != 0.0 */\r\n            c->im = a.im / b.re;\r\n            if (a.re == 0.0) {\r\n                c->re = 0.0;\r\n            }\r\n        }\r\n    } else if (b.re == 0.0) { /* b.im != 0.0 */\r\n        c->re = a.im / b.im;\r\n        c->im = -a.re / b.im;\r\n        if (a.re == 0.0) {\r\n            c->im = 0.0;\r\n        } else if (a.im == 0.0) {\r\n            c->re = 0.0;\r\n        }\r\n    } else {\r\n        real_T brm = fabs(b.re);\r\n        real_T bim = fabs(b.im);\r\n        if (brm > bim) {\r\n            real_T s = b.im / b.re;\r\n            real_T d = b.re + s * b.im;\r\n            c->im = (a.im - s * a.re) / d;\r\n            c->re = (a.re + s * a.im) / d;\r\n        } else if (brm == bim) {\r\n            real_T half = 0.5;\r\n            real_T sgnbr = b.re > 0.0 ? half : -half;\r\n            real_T sgnbi = b.im > 0.0 ? half : -half;\r\n            c->im = (a.im*sgnbr - a.re*sgnbi)/brm;\r\n            c->re = (a.re*sgnbr + a.im*sgnbi)/brm;\r\n        } else {\r\n            real_T s = b.re / b.im;\r\n            real_T d = b.im + s * b.re;\r\n            c->im = (s * a.im - a.re) / d;\r\n            c->re = (s * a.re + a.im) / d;\r\n        }\r\n    }\r\n}\r\n\r\nvoid rt_ComplexReciprocal_Dbl(creal_T* Out,\r\n                              const creal_T In1)\r\n{\r\n    creal_T y;\r\n    y.re = 1.0;\r\n    y.im = 0.0;\r\n\r\n    rt_ComplexRDivide_Dbl(Out, y, In1);\r\n}\r\n\r\n#endif\r\n\r\n\r\nreal_T rt_Hypot_Dbl(real_T a, real_T b)\r\n{\r\n    real_T y;\r\n    if (a != a || b != b) {\r\n        y = a + b;\r\n    } else {\r\n        real_T t;\r\n        if (fabs(a) > fabs(b)) {\r\n            t = b/a;\r\n            y = fabs(a)*sqrt(1.0 + t*t);\r\n        } else {\r\n            if (b == 0.0) {\r\n                y = 0.0;\r\n            } else {\r\n                t = a/b;\r\n                y = fabs(b)*sqrt(1.0 + t*t);\r\n            }\r\n        }\r\n    }\r\n    \r\n    return y;\r\n}\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};